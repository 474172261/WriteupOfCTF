函数A具有"域"的数学属性,但是我们只关心计算,那么它有以下属性:

A(1)\*A(x)=A(x)\*A(1)=A(1) 乘法单位元 </br>
A(0)+A(x)=A(x)+A(0)=A(x) 加法单位元
A(x)\*A(y)=A(y)\*A(x) 交换律
A(x)\*(A(y)+A(z))=A(x)\*A(y)+A(x)\*A(z) 结合律
if A(x)\*A(y)=A(z),A(z)/A(x)=A(y) 乘法是除法的逆运算
特别的 A(x)-A(y)=A(x)+A(y),另外A(x+y)!=A(x)+A(y).

那么针对一次SchLupp的split函数转换后,我们有:
Y = S+X0\*B+X1\*B\*X+X2\*B\*X^2+X3\*B\*X^3+X4\*B\*X^4.
Y代表结果,X0,X1...分别代表secrets的每个值,其中X0就是传入字符.

简化公式后有:
Y=X0+X1\*X+X2\*X^2+X3\*X^3+X4\*X^4

Y其实就是intercepted_1中split的第二个参数的每个字节,
X就是第一个参数的每个字节.而split只有4组,现在我们只有4组解.
因此最后化简公式后,我们可以得到一个l\*Y=j\*X0+k\*X1一组二元一次方程.
通过测试intercepted_2.可以确认两个文件并不是同一个SchLupp函数的输出.

通过求解第一组,得到前四个字符为如下公式:
A(17) = A(1)\*X0+A(90)\*X1
简化表达为:
17 = 1 90 
135 = 1 87 
155 = 1 83 
43 = 1 123 

猜测前4个字节为flag,因此代入256个字符作为X1,求解X0找出符合flag的字符结果.得到唯一解.

操作见sovle.py.
